ئورد رجكس؛
ئورد مجال من مصفوفة؛
ئورد الكل ك رياضيات من رياضيات؛
ئورد مفتاحين من نوعمركب؛
ئورد بتشمرفق، بتشدبي، نتجقاب من مكون.بتشدبي؛

ئورد الكل ك مجالمشروع من صنفمجال.مشروع؛
ئورد الكل ك مجالوحدة من صنفمجال.وحدة؛

ئورد مختطوحدة من صنفمجال.وحدة؛
ئورد مختطمشروع من صنفمجال.مشروع؛

ئعلن مركب مختطبطاقة:
	نصية _معرف،
	نصية _مراجعة،
	منطق _محدوف،
	بتشمرفق[] _مرفقات،
	تعداد نوع [بطاقة]،
	تعداد نوعبطاقة [ئوردين، متغيرين، وضيفة، مركبين]،
	نصية عنوان،
	نصية وحدة،
	نصية معرفمشروع،
	نصية محتوا،
	عدد رتبة
تم

ئعلن ئستولدمعرف (عدد طول = 6) ك نصية:
	نصية محرفين = 'ئبجدهوزحطيكلمنصعفصقرشتخضغ0123456789'؛
	نصية نتج = ''؛
	لكل ع في مجال(0، طول):
		عدد مئشرعشوائي = رياضيات.ئستصغر(رياضيات.عشوائي() × محرفين.طول)؛
		نتج = نتج + محرفين[مئشرعشوائي]؛
	تم
	ئرجع نتج؛
تم

ئعلن عنوانمنمحتوا (نصية محتو):
	#رجكس رج = رجكس('ئعلن\\s*(.+)\\s*\\(\\s*?\\)(\\s*):')؛
	رجكس رج = رجكس('ئعلن\\s+(.+)\\s*\\(\\s*([^\\)]*)\\s*\\)\\s*.*\\s*:'، 'u')؛
	نصية[] نتج = محتو.طابق(رج)؛
	ئدا نتج:
		ئرجع نتج[1].قللم()؛
	وئلا:
		ئرجع ''؛
	تم
تم

ئعلن ئنشئبطاقة (نصية مساروحدة، نصية محتوا، تعداد [ئوردين، متغيرين، وضيفة، مركبين] نوعبطاقة؟) ك مختطبطاقة:
	ئدا ليس نوعبطاقة:
		رجكس رجئورد = رجكس('ئورد [^؛]+؛'، 'g')؛
		رجكس رجمتغ = رجكس('ئعلن [^؛(]+؛'، 'g')؛
		رجكس رجمركب = رجكس('ئعلن مركب(?:(?!ئعلن)[\\s\\S])*تم'، 'g')؛
		رجكس رجوضف = رجكس('ئعلن(?:(?!ئعلن)[\\s\\S])*تم'، 'g')؛
		
		نصية[] ئوردين = محتوا.طابق(رجئورد) ئو []؛
		نصية[] متغيرين = محتوا.طابق(رجمتغ) ئو []؛
		نصية[] وضيفات = محتوا.طابق(رجوضف) ئو []؛
		نصية[] مركبين = محتوا.طابق(رجمركب) ئو []؛
		
		ئدا ئوردين.طول:
			نوعبطاقة = 'ئوردين'؛
		تم
		ئدا متغيرين.طول:
			نوعبطاقة = 'متغيرين'؛
		تم
		ئدا وضيفات.طول:
			نوعبطاقة = 'وضيفة'؛
		تم
		ئدا مركبين.طول:
			نوعبطاقة = 'مركبين'؛
		تم
	تم
	
	عدد رتبة = 10؛
	ئدا نوعبطاقة == 'ئوردين':
		رتبة = 0؛
	وئلا ئدا نوعبطاقة == 'متغيرين':
		رتبة = 2؛
	وئلا ئدا نوعبطاقة == 'مركبين':
		رتبة = 1؛
	تم
	
	ئرجع {
		_معرف: ئستولدمعرف(10)،
		نوع: 'بطاقة'،
		عنوان: عنوانمنمحتوا(محتوا)،
		وحدة: مساروحدة،
		معرفمشروع: 'مشروع'،
		محتوا: محتوا،
		نوعبطاقة: نوعبطاقة،
		رتبة: رتبة
	}؛
تم

#بطاقات المشروع لا تتضمن بطاقات المكتبة الئساسية
ئعلن ردبطامشروع (بتشدبي قاب) ك وعد مختطبطاقة[]:
	نتجقاب نتج = ريتما قاب.ئستعلم(
		حدد: {
			نوع: 'بطاقة'
		}،
		ئحصر: 3000
	)؛
	مختطبطاقة[] بطا = نتج.وتيقات؛
	بطا = بطا.رششح(دالة(مختطبطاقة بط): ليس بط.وحدة.يبدئب('ئساسية'))؛
	ئرجع بطا؛
تم

ئعلن ئبحتبطاقات (بتشدبي قاب، نصية مبحت) ك وعد مختطبطاقة[]:
	مختطبطاقة[] بطا = ريتما ردبطامشروع(قاب)؛
	ئدا مبحت لا= '':
		بطا = بطا.رششح(دالة(وتق): وتق.محتوا.يتضمن(مبحت))؛
	تم
	ئرجع بطا؛
تم

ئعلن بطاقاتئلامحتوا (بتشدبي قاب) ك وعد مركب[] {نصية مسار، نصية محتوا}:
	مركب[] {نصية مسار، نصية محتوا} نتيجة = []؛
	
	مختطمشروع مشروعحالي = مجالمشروع.ردمشروعحالي(قاب)؛
	مختطوحدة[] وحدات = مجالوحدة.ردجميعوحدات(قاب)؛
	
	#ترشيح الوحدات التي تم تعديلها بعد ئاخر ئيداع
	وحدات = وحدات.رششح(دالة(وح): وح.ئاخرتعديل > مشروعحالي.ئاخرئيداع)؛
	
	نتجقاب نتج؛
	لكل وحدة في وحدات:
		نتج = ريتما قاب.ئستعلم(
			حدد: {
				نوع: 'بطاقة'،
				وحدة: وحدة.مسار
			}،
			ئحصر: 3000
		)؛
		مختطبطاقة[] بطاقات = نتج.وتيقات؛
		نصية[] محتوين = بطاقات.طببق(دالة (مختطبطاقة بط): بط.محتوا)؛
		نتيجة.ئدفع({
			مسار: وحدة.مسار،
			محتوا: محتوين.ئدمج('\n')
		})؛
	تم
تم

ئعلن بطاقاتمنوحدة (بتشدبي قاب، نصية مساروحدة) ك وعد مختطبطاقة[]:
	#نجلب بطاقات الوحدة
	مركب {وتيقات} نتج = ريتما قاب.ئستعلم(
		حدد: {
			نوع: 'بطاقة'،
			وحدة: مساروحدة
		}،
		ئحصر: 3000
	)؛
	مختطبطاقة[] بطاقات = نتج.وتيقات؛
	بطاقات.رتتب(دالة(مختطبطاقة ئ، مختطبطاقة ب): ئ.رتبة - ب.رتبة)؛
	ئرجع بطاقات؛
تم

ئعلن ردئسمفقط (مختطبطاقة بط) ك نصية:
	ئدا بط.عنوان == '':
		ئرجع ''؛
	تم
	نصية[] مقسم = بط.عنوان.قسسم('.')؛
	نصية ئسم = مقسم[مقسم.طول-1]؛
	ئسم = ئسم.عووض('('، '').عووض(')'، '')؛
	ئرجع ئسم؛
تم

#تضبط رتبة البطاقات المعطاة حسب ئعتمادياتها
ئعلن رتتبطاقات (مختطبطاقة[] بطا) ك وعد مركب {منطق هلنجح، مختطبطاقة[] مفروز، نصية نصخطئ}:
	#بنائ مبيان الئعتمادية
	#طباق<نصية، مختطبطاقة[]> مبيان = طباق()؛
	#طباق<نصية، عدد> فيدرجة = طباق()؛	
	مركب مبيان = {}؛
	مركب فيدرجة = {}؛
	
	#يبدئ الترتيب من 10
	#لئن هناك نوعين بطاقات ئاخرين لا يدخلون في الترتيب
	عدد ئساسترتيب = 10؛
	
	لكل بط في بطا:
		نصية ئسم = ردئسمفقط(بط)؛
		
		#مبيان.خد(بط._معرف، [])؛
		مبيان[بط._معرف] = []؛ #لكل معرف مصفوفة بطاقات ئعتمادياته
		
		#فيدرجة.خد(بط._معرف، 0)؛
		فيدرجة[بط._معرف] = 0؛ #لكل معرف درجة الئعتمادية
	تم
	
	نصية[] نصئعتمادات = []؛
	#ملئ المبيان بالئعتماديات
	لكل بط1 في بطا:
		نصية ئسم1 = ردئسمفقط(بط1)؛
		لكل بط2 في بطا:
			نصية ئسم2 = ردئسمفقط(بط2)؛
			رجكس رج = رجكس("(?<![\\w\\p{L}\\p{N}])${ئسم2}(?=(\\s|\\(|\\)|;|\\.|$))"، 'gu')؛
			ئدا ئسم1 == '': #البطاقة 1 ليست وضيفة وئنما متغيرين
				ئدا (ئسم1 لا= ئسم2) وو رج.ئختبر(بط1.محتوا):
					نصئعتمادات.ئدفع("%{بط1.عنوان} تعتمد %{بط2.عنوان}")؛
					مبيان[بط2._معرف].ئدفع(بط1)؛				
					فيدرجة[بط1._معرف] = فيدرجة[بط1._معرف] + 1؛
				تم
			وئلا ئدا ئسم2 == '': #البطاقة 2 ليست وضيفة وئنما متغيرين
				#تجاهل
				ئسم2 = ئسم2؛
			وئلا ئدا (ئسم1 لا= ئسم2) وو (ليس بط1.محتوا.يبدئب('#')) وو رج.ئختبر(بط1.محتوا):
				نصئعتمادات.ئدفع("%{بط1.عنوان} تعتمد %{بط2.عنوان}")؛
				مبيان[بط2._معرف].ئدفع(بط1)؛				
				فيدرجة[بط1._معرف] = فيدرجة[بط1._معرف] + 1؛
			تم
		تم
	تم
	
	#عمل الفرز الطبولوجي
	مختطبطاقة[] مفروز = []؛ #البطاقات المفروزة
	نصية[] طابور = []؛ #طابور معرفات البطاقات قيد المعالجة
	
	#بدئ بالبطاقات من دون ئعتاديات
	لكل معرفبطاقة في مفتاحين(فيدرجة):
		عدد رتبة = فيدرجة[معرفبطاقة]؛
		ئدا رتبة == 0:
			طابور.ئدفع(معرفبطاقة)؛
		تم
	تم
	
	طالما طابور.طول:
		نصية معرفحالية = طابور.ئزح()؛
		مختطبطاقة بطق = بطا.ئوجد(دالة(مختطبطاقة ط): ط._معرف == معرفحالية)؛
		مفروز.ئدفع(بطق)؛
		
		مختطبطاقة[] بطقمعتمدات = مبيان[معرفحالية]؛
		لكل بطقمعتمدة في بطقمعتمدات:
			فيدرجة[بطقمعتمدة._معرف] = فيدرجة[بطقمعتمدة._معرف] - 1؛
			
			ئدا فيدرجة[بطقمعتمدة._معرف] == 0:
				طابور.ئدفع(بطقمعتمدة._معرف)؛
			تم
		تم
	تم
	
	#تحقق من الئعتماديات الدائرية
	مختطبطاقة[] ئعتدائريات = []؛
	لكل معرفبطاقة في مفتاحين(فيدرجة):
		عدد رتبة = فيدرجة[معرفبطاقة]؛
		ئدا رتبة > 0:
			مختطبطاقة بط = بطا.ئوجد(دالة(مختطبطاقة ط): ط._معرف == معرفبطاقة)؛
			ئعتدائريات.ئدفع(بط)؛
		تم
	تم
	
	ئدا ئعتدائريات.طول:
		ئرجع {
			هلنجح: خطئ،
			مفروز: ئعتدائريات،
			نصخطئ: نصئعتمادات.ئدمج('\n')
		}؛
	تم
	
	عدد ع = ئساسترتيب؛
	لكل بط في مفروز:
		بط.رتبة = ع؛
		ع = ع + 1؛
	تم
	
	ئرجع {
		هلنجح: صحيح،
		مفروز: مفروز
	}؛
تم


ئعلن بطاقاتمنمحتوا (نصية معرفمشروع، نصية مساروحدة، نصية محتوا) ك وعد مختطبطاقة[]:
	مختطبطاقة[] بطاقات = []؛
	
	ئدا مساروحدة.ينتهيب('.جني'):	
		رجكس رجئورد = رجكس('#?ئورد [^؛]+؛'، 'g')؛
		رجكس رجمتغ = رجكس('#?ئعلن [^؛(]+؛'، 'g')؛
		رجكس رجمركب = رجكس('#?ئعلن مركب(?:(?!ئعلن)[\\s\\S])*تم'، 'g')؛
		رجكس رجبنية = رجكس('#?ئعلن بنية(?:(?!ئعلن)[\\s\\S])*تم'، 'g')؛
		رجكس رجوضف = رجكس('#?ئعلن(?:(?!ئعلن)[\\s\\S])*تم'، 'g')؛
		
		نصية[] ئوردين = محتوا.طابق(رجئورد) ئو []؛
		نصية[] متغيرين = محتوا.طابق(رجمتغ) ئو []؛
		نصية[] مركبين = محتوا.طابق(رجمركب) ئو []؛
		نصية[] بنيات = محتوا.طابق(رجبنية) ئو []؛
		نصية[] وضيفات = محتوا.طابق(رجوضف) ئو []؛
		
		مختطبطاقة[] بطافرز = []؛
		
		ئدا ئوردين.طول:
			بطاقات.ئدفع(ئنشئبطاقة(مساروحدة، ئوردين.ئدمج('\n')، 'ئوردين'))؛
		تم
		ئدا متغيرين.طول:
			بطافرز.ئدفع(ئنشئبطاقة(مساروحدة، متغيرين.ئدمج('\n')، 'متغيرين'))؛
		تم
		ئدا مركبين.طول:
			بطاقات.ئدفع(ئنشئبطاقة(مساروحدة، مركبين.ئدمج('\n')، 'مركبين'))؛
		تم
		ئدا بنيات.طول:
			بطاقات.ئدفع(ئنشئبطاقة(مساروحدة، بنيات.ئدمج('\n')، 'مركبين'))؛
		تم
		
		لكل طاوضف في وضيفات:
			ئدا (طاوضف لا= '') وو (ليس طاوضف.يتضمن('ئعلن مركب')) وو (ليس طاوضف.يتضمن('ئعلن بنية')):
				بطافرز.ئدفع(ئنشئبطاقة(مساروحدة، طاوضف، 'وضيفة'))؛
			تم
		تم
		# ترتيب البطاقات
		مركب {منطق هلنجح، مختطبطاقة[] مفروز، نصية نصخطئ} نتج = ريتما رتتبطاقات(بطافرز)؛
		
		ئدا ليس نتج.هلنجح:
			قل "ئعتماديات دائرية في الوحدة: %{مساروحدة}"؛
			قل نتج.نصخطئ؛
			قل نتج.مفروز؛
			بطافرز = عدم؛
		وئلا:
			بطافرز = نتج.مفروز؛
		تم
		
		بطاقات = [...بطاقات، ...بطافرز]؛
	تم
	
	ئرجع بطاقات؛
تم


ئعلن ئحفض (بتشدبي قاب، مختطبطاقة بط) ك وعد:
	ريتما قاب.ئوضع(بط)؛
تم

ئعلن ئحدف (بتشدبي قاب، مختطبطاقة بط) ك وعد مركب {منطق حدفبطاقة، منطق حدفوحدة}:
	مركب {منطق حدفبطاقة، منطق حدفوحدة} نتج؛
	بط._محدوف = صحيح؛
	ريتما قاب.ئوضع(بط)؛
	نتج.حدفبطاقة = صحيح؛
	نتج.حدفوحدة = خطئ؛
	
	#نحدف وحدة البطاقة ئدا لم تبقا فيها بطاقات ئخريات
	مختطبطاقة[] بطا = ريتما بطاقاتمنوحدة(قاب، بط.وحدة)؛
	ئدا بطا.طول == 0:
		مختطوحدة وح = ريتما قاب.ئجلب(بط.وحدة)؛
		ريتما مجالوحدة.ئحدف(قاب، وح)؛
		نتج.حدفوحدة = صحيح؛
	تم
	
	ئرجع نتج؛
تم

